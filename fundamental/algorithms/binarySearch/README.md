# Бінарний пошук (Binary Search)

## Опис

Бінарний пошук - це ефективний алгоритм пошуку елемента в відсортованому масиві. Алгоритм працює шляхом порівняння шуканого значення з середнім елементом масиву та виключення половини масиву на кожному кроці.

## Основні принципи

- **Відсортований масив**: Алгоритм працює тільки з відсортованими масивами
- **Розділення навпіл**: На кожному кроці виключається половина масиву
- **Логарифмічна складність**: Час виконання O(log n)
- **Ефективність**: Набагато швидший за лінійний пошук для великих масивів

## Переваги

- ✅ Дуже швидкий для великих масивів
- ✅ Логарифмічна складність O(log n)
- ✅ Ефективне використання пам'яті
- ✅ Простий у реалізації
- ✅ Стабільний алгоритм

## Недоліки

- ❌ Потребує відсортований масив
- ❌ Не працює з невідсортованими даними
- ❌ Складність у реалізації для складних структур даних
- ❌ Не підходить для пошуку найближчих значень

## Коли використовувати

- Коли масив відсортований
- Коли потрібен швидкий пошук
- Коли масив великий (більше 100 елементів)
- Коли потрібно знайти точне значення
- Коли потрібна ефективність

## Алгоритм

### Кроки виконання

1. **Ініціалізація**: Встановити початкові межі (min = 0, max = length - 1)
2. **Цикл**: Поки min <= max
3. **Середній елемент**: Обчислити mid = (min + max) / 2
4. **Порівняння**: Порівняти arr[mid] з шуканим значенням
5. **Вибір половини**: 
   - Якщо arr[mid] < target: min = mid + 1
   - Якщо arr[mid] > target: max = mid - 1
   - Якщо arr[mid] == target: повернути mid
6. **Повернення**: Якщо не знайдено, повернути -1

## Реалізація (binarySearch.js)

### Аналіз коду

#### 1. Рекурсивна реалізація

```javascript
const binarySearch = (arr, value, minIndex, maxIndex) => {
  const min = typeof minIndex === 'number' ? minIndex : 0;
  const max = typeof maxIndex === 'number' ? maxIndex : (arr.length - 1);

  if (min > max) return -1;

  const mid = Math.floor((max + min) / 2);
  const midValue = arr[mid];

  if (midValue < value) {
    return binarySearch(arr, value, mid + 1, max);
  }
  if (midValue > value) {
    return binarySearch(arr, value, min, mid - 1);
  }

  return mid;
}
```

**Особливості:**
- **Рекурсивний підхід**: Викликає сам себе з новими межами
- **Параметри за замовчуванням**: minIndex та maxIndex опціональні
- **Базовий випадок**: min > max означає, що елемент не знайдено
- **Рекурсивні виклики**: Зменшує область пошуку на кожному кроці

#### 2. Ітеративна реалізація

```javascript
const binarySearch = (array, targetValue) => {
  let min = 0;
  let max = array.length - 1;
  let guess;

  while(min <= max) {
    guess = Math.floor((max + min)/2, 10);

    if(array[guess] === targetValue) {
      return guess;
    } else if (array[guess] < targetValue) {
      min = guess + 1;
    } else if (array[guess] > targetValue) {
      max = guess - 1;
    }
  }

  return -1;
};
```

**Особливості:**
- **Ітеративний підхід**: Використовує цикл while
- **Змінні стану**: min, max, guess для відстеження поточного стану
- **Умовна логіка**: Три випадки порівняння
- **Повернення результату**: Індекс або -1

#### 3. Тестування

```javascript
describe('binarySearch', () => {
  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];

  test('not exist', () => {
    expect(binarySearch(primes, 4)).toBe(-1);
  });
  test('second', () => {
    expect(binarySearch(primes, 3)).toBe(1);
  });
  // ... інші тести
});
```

**Особливості:**
- **Тестовий масив**: Масив простих чисел (відсортований)
- **Різні сценарії**: Пошук існуючих та неіснуючих елементів
- **Перевірка всіх елементів**: Тест для кожного елемента масиву
- **Валідація**: Перевірка правильності індексів

## Порівняння реалізацій

### Рекурсивна vs Ітеративна

| Аспект | Рекурсивна | Ітеративна |
|--------|------------|------------|
| **Читабельність** | Більш зрозуміла | Менш зрозуміла |
| **Пам'ять** | Використовує стек викликів | Менше використання пам'яті |
| **Швидкість** | Трохи повільніша | Трохи швидша |
| **Складність** | Простіша логіка | Складніша логіка |

## Складність

### Часова складність
- **Найкращий випадок**: O(1) - елемент в середині
- **Середній випадок**: O(log n) - логарифмічний
- **Найгірший випадок**: O(log n) - логарифмічний

### Просторова складність
- **Рекурсивна**: O(log n) - глибина рекурсії
- **Ітеративна**: O(1) - константна пам'ять

## Приклади використання

### 1. Пошук в масиві чисел
```javascript
const numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
const index = binarySearch(numbers, 7); // 3
```

### 2. Пошук в масиві рядків
```javascript
const names = ['Alice', 'Bob', 'Charlie', 'David', 'Eve'];
const index = binarySearch(names, 'Charlie'); // 2
```

### 3. Пошук в масиві об'єктів
```javascript
const users = [
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' },
  { id: 3, name: 'Charlie' }
];
// Потребує спеціальної реалізації для об'єктів
```

## Розширення функціональності

### Пошук найближчого елемента
```javascript
const findClosest = (arr, target) => {
  let min = 0;
  let max = arr.length - 1;
  let closest = -1;
  let minDiff = Infinity;

  while (min <= max) {
    const mid = Math.floor((min + max) / 2);
    const diff = Math.abs(arr[mid] - target);
    
    if (diff < minDiff) {
      minDiff = diff;
      closest = mid;
    }
    
    if (arr[mid] < target) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
  }
  
  return closest;
};
```

### Пошук першого/останнього входження
```javascript
const findFirst = (arr, target) => {
  let min = 0;
  let max = arr.length - 1;
  let result = -1;

  while (min <= max) {
    const mid = Math.floor((min + max) / 2);
    
    if (arr[mid] === target) {
      result = mid;
      max = mid - 1; // Продовжуємо пошук ліворуч
    } else if (arr[mid] < target) {
      min = mid + 1;
    } else {
      max = mid - 1;
    }
  }
  
  return result;
};
```

## Альтернативи

1. **Лінійний пошук** - O(n), працює з невідсортованими масивами
2. **Хеш-таблиця** - O(1), але потребує додаткової пам'яті
3. **Дерево пошуку** - O(log n), для динамічних даних
4. **Індексований пошук** - для складних структур даних

## Висновок

Бінарний пошук - це один з найефективніших алгоритмів пошуку для відсортованих масивів. Він забезпечує логарифмічну складність O(log n) та є основою для багатьох інших алгоритмів. Алгоритм особливо корисний для великих масивів, де лінійний пошук був би занадто повільним.
