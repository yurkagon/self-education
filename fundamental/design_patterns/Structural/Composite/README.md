# Патерн Composite (Композит)

Багато об'єктів вести себе як один об"єкт.

## Опис

Composite - це структурний патерн проектування, який дозволяє збирати об'єкти в деревоподібні структури та працювати з ними як з окремими об'єктами. Патерн використовує рекурсивну композицію для створення ієрархій частина-ціле.

## Основні принципи

- **Єдиний інтерфейс**: Листи та композити мають однаковий інтерфейс
- **Рекурсія**: Композит може містити інші композити
- **Прозорість**: Клієнт не знає, чи працює з листом чи композитом
- **Гнучкість**: Легко додавати нові типи компонентів
- **Ієрархія**: Підтримує деревоподібні структури

## Переваги

- ✅ Єдиний інтерфіс для листів та композитів
- ✅ Легко додавати нові типи компонентів
- ✅ Підтримує складні ієрархії
- ✅ Спрощує роботу з групами об'єктів
- ✅ Рекурсивна обробка
- ✅ Гнучкість у структурі

## Недоліки

- ❌ Може ускладнити дизайн
- ❌ Складність у розумінні
- ❌ Потенційні проблеми з продуктивністю
- ❌ Може призвести до глибоких ієрархій
- ❌ Складність у налагодженні

## Коли використовувати

- Коли потрібно працювати з ієрархіями об'єктів
- Коли хочете єдиний інтерфейс для листів та композитів
- Коли потрібна рекурсивна обробка
- Коли структура може змінюватися динамічно
- Коли хочете спростити роботу з групами

## Структура патерну

### Компоненти

1. **Component** - базовий компонент
2. **Leaf** - лист (простий елемент)
3. **Composite** - композит (контейнер)
4. **Client** - клієнт

## Реалізація (base.ts)

### Аналіз коду

#### 1. Базовий компонент
```typescript
interface Component {
  getPrice(): number;
}
```

**Особливості:**
- **Інтерфейс**: Визначає спільний контракт
- **Єдиність**: Однаковий для всіх компонентів
- **Простота**: Мінімальний набір методів

#### 2. Лист (Product)
```typescript
class Product implements Component {
  constructor(private price: number) {}

  getPrice(): number {
    return this.price;
  }
}
```

**Особливості:**
- **Простота**: Базовий елемент без дітей
- **Реалізація**: Конкретна логіка
- **Незалежність**: Не містить інших компонентів

#### 3. Композит (Box)
```typescript
class Box implements Component {
  private items: Component[] = [];

  add(item: Component): void {
    this.items.push(item);
  }

  getPrice(): number {
    return this.items.reduce((total, item) => total + item.getPrice(), 0);
  }
}
```

**Особливості:**
- **Контейнер**: Містить масив компонентів
- **Додавання**: Метод для додавання елементів
- **Агрегація**: Сумує ціни всіх дітей
- **Рекурсія**: Викликає getPrice() для всіх дітей

#### 4. Використання
```typescript
const product1 = new Product(10);
const product2 = new Product(20);
const product3 = new Product(30);

const box = new Box();
box.add(product1);
box.add(product2);
box.add(product3);

console.log('Total price:', box.getPrice());
```

**Особливості:**
- **Створення**: Спочатку створюються листи
- **Додавання**: Потім додаються до композиту
- **Обробка**: Композит автоматично обробляє всіх дітей

## Приклади використання

### 1. Файлова система
- **Лист**: Файл
- **Композит**: Папка
- **Операція**: Розрахунок розміру

### 2. UI компоненти
- **Лист**: Кнопка, Текст
- **Композит**: Панель, Форма
- **Операція**: Рендеринг

### 3. Організаційна структура
- **Лист**: Співробітник
- **Композит**: Відділ
- **Операція**: Розрахунок зарплати

## Розширення функціональності

### Додавання видалення
```typescript
class Box implements Component {
  remove(item: Component): void {
    const index = this.items.indexOf(item);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  }
}
```

### Додавання пошуку
```typescript
class Box implements Component {
  find(predicate: (item: Component) => boolean): Component | null {
    for (const item of this.items) {
      if (predicate(item)) {
        return item;
      }
      if (item instanceof Box) {
        const found = item.find(predicate);
        if (found) return found;
      }
    }
    return null;
  }
}
```

## Порівняння з іншими патернами

### Composite vs Decorator
- **Composite**: Створює ієрархії об'єктів
- **Decorator**: Додає функціональність до об'єкта

### Composite vs Chain of Responsibility
- **Composite**: Структурна ієрархія
- **Chain**: Ланцюжок обробки запитів

### Composite vs Tree
- **Composite**: Патерн проектування
- **Tree**: Структура даних

## Альтернативи

1. **Tree Structure** - для простих ієрархій
2. **Visitor Pattern** - для складних операцій
3. **Iterator Pattern** - для обходу структури
4. **Recursive Functions** - для простих випадків

## Висновок

Composite - це потужний патерн для роботи з ієрархічними структурами. Він особливо корисний коли потрібно працювати з групами об'єктів як з єдиним об'єктом, але може ускладнити дизайн для простих випадків.
