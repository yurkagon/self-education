# Патерн Proxy (Проксі)

реальний і проксі об'єкт наслідують один інтерфейс, проксі перевикористовує оригінальний

## Опис

Proxy - це структурний патерн проектування, який надає заміну або заглушку для іншого об'єкта. Проксі контролює доступ до оригінального об'єкта, дозволяючи виконувати дії до або після передачі запиту до оригінального об'єкта.

## Основні принципи

- **Контроль доступу**: Проксі контролює доступ до об'єкта
- **Прозорість**: Клієнт не знає, що працює з проксі
- **Делегування**: Проксі передає запити до оригінального об'єкта
- **Додаткова логіка**: Можна додавати функціональність
- **Кешування**: Можна кешувати результати

## Переваги

- ✅ Контроль доступу до об'єкта
- ✅ Додаткова функціональність без зміни об'єкта
- ✅ Ліниве завантаження
- ✅ Кешування результатів
- ✅ Логування та моніторинг
- ✅ Безпека та валідація

## Недоліки

- ❌ Додає складність до коду
- ❌ Може зменшити продуктивність
- ❌ Складність у налагодженні
- ❌ Потенційні проблеми з пам'яттю
- ❌ Може приховати проблеми

## Коли використовувати

- Коли потрібен контроль доступу
- Коли хочете додати функціональність без зміни об'єкта
- Коли потрібне ліниве завантаження
- Коли хочете кешувати результати
- Коли потрібне логування або моніторинг

## Структура патерну

### Компоненти

1. **Subject** - інтерфейс справжнього об'єкта
2. **RealSubject** - справжній об'єкт
3. **Proxy** - проксі об'єкт
4. **Client** - клієнт

## Реалізація (base.ts)

### Аналіз коду

#### 1. Інтерфейс Subject
```typescript
interface Subject {
  request: (str: string) => Array<any>
}
```

**Особливості:**
- **Інтерфейс**: Визначає контракт для справжнього об'єкта
- **Метод**: `request` приймає рядок та повертає масив
- **Спільність**: Використовується як справжнім об'єктом, так і проксі

#### 2. Справжній об'єкт (RealSubject)
```typescript
class RealSubject implements Subject {
  request(str) {
    return [str];
  }
}
```

**Особливості:**
- **Простота**: Базова реалізація без додаткової логіки
- **Прямий доступ**: Виконує запит безпосередньо
- **Ефективність**: Мінімальна накладність

#### 3. Проксі (ProxySubject)
```typescript
class ProxySubject implements Subject {
  private subject: Subject;

  constructor(subject: Subject) {
    this.subject = subject;
  }

  request(str: string) {
    console.log(str);
    const result = this.subject.request(str);
    console.log(result);
    return result;
  }
}
```

**Особливості:**
- **Композиція**: Містить посилання на справжній об'єкт
- **Делегування**: Передає запит до справжнього об'єкта
- **Додаткова логіка**: Логує вхідні та вихідні дані
- **Прозорість**: Має той самий інтерфейс

#### 4. Використання
```typescript
const subject = new RealSubject();
const proxySubject = new ProxySubject(subject);

clientCode(subject);      // Прямий доступ
clientCode(proxySubject); // Через проксі
```

**Особливості:**
- **Порівняння**: Показує різницю між прямим доступом та проксі
- **Прозорість**: Клієнт працює з однаковим інтерфейсом
- **Гнучкість**: Можна легко переключатися між прямим доступом та проксі

## Типи Proxy патернів

### 1. Virtual Proxy (Віртуальний проксі)
- Ліниве завантаження об'єктів
- Створює об'єкт тільки при потребі
- Економить пам'ять

### 2. Remote Proxy (Віддалений проксі)
- Представляє об'єкт в іншому адресному просторі
- Використовується для мережевих об'єктів
- Приховує складність мережевого доступу

### 3. Protection Proxy (Захисний проксі)
- Контролює доступ до об'єкта
- Перевіряє права доступу
- Забезпечує безпеку

### 4. Smart Proxy (Розумний проксі)
- Додає додаткову функціональність
- Логування, кешування, моніторинг
- Оптимізація доступу

## Приклади використання

### 1. Ліниве завантаження
```typescript
class LazyImageProxy {
  private realImage: RealImage | null = null;
  
  display(): void {
    if (!this.realImage) {
      this.realImage = new RealImage();
    }
    this.realImage.display();
  }
}
```

### 2. Кешування
```typescript
class CachingProxy {
  private cache: Map<string, any> = new Map();
  
  request(key: string): any {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    const result = this.realSubject.request(key);
    this.cache.set(key, result);
    return result;
  }
}
```

### 3. Валідація
```typescript
class ValidationProxy {
  request(data: string): any {
    if (!this.isValid(data)) {
      throw new Error('Invalid data');
    }
    return this.realSubject.request(data);
  }
}
```

## Порівняння з іншими патернами

### Proxy vs Decorator
- **Proxy**: Контролює доступ до об'єкта
- **Decorator**: Додає функціональність до об'єкта

### Proxy vs Adapter
- **Proxy**: Має той самий інтерфейс
- **Adapter**: Змінює інтерфейс об'єкта

### Proxy vs Facade
- **Proxy**: Замінює один об'єкт
- **Facade**: Спрощує інтерфейс до групи об'єктів

## Альтернативи

1. **Direct Access** - для простих випадків
2. **Middleware** - для обробки запитів
3. **Interceptor** - для перехоплення викликів
4. **Wrapper** - для обгортання функціональності

## Висновок

Proxy - це потужний патерн для контролю доступу та додавання функціональності. Він особливо корисний для лінивого завантаження, кешування, валідації та безпеки, але може додати складність до коду.
