# Патерн Bridge (Міст)

Виносить певну логіку класу в окремий клас

## Опис

Bridge - це структурний патерн проектування, який розділяє абстракцію від її імплементації, дозволяючи їм змінюватися незалежно. Патерн використовує композицію замість наслідування для зв'язування абстракції з імплементацією.

## Основні принципи

- **Розділення**: Абстракція та імплементація розділені
- **Композиція**: Використовує композицію замість наслідування
- **Незалежність**: Абстракція та імплементація можуть змінюватися окремо
- **Гнучкість**: Легко додавати нові абстракції та імплементації
- **Розширюваність**: Підтримує принцип відкритості/закритості

## Переваги

- ✅ Розділяє абстракцію від імплементації
- ✅ Дозволяє незалежні зміни
- ✅ Покращує розширюваність
- ✅ Уникнення проблем з наслідуванням
- ✅ Легко додавати нові варіанти
- ✅ Підтримує принцип OCP

## Недоліки

- ❌ Складність архітектури
- ❌ Може бути надмірним для простих випадків
- ❌ Велика кількість класів
- ❌ Складність у розумінні
- ❌ Потенційна плутанина в коді

## Коли використовувати

- Коли потрібно розділити абстракцію від імплементації
- Коли хочете уникнути проблем з наслідуванням
- Коли потрібна гнучкість у комбінуванні
- Коли імплементація може змінюватися під час виконання
- Коли хочете приховати деталі імплементації

## Структура патерну

### Компоненти

1. **Abstraction** - абстракція
2. **Refined Abstraction** - уточнена абстракція
3. **Implementor** - імплементатор
4. **Concrete Implementor** - конкретна імплементація
5. **Client** - клієнт

## Реалізація (base.ts)

### Аналіз коду

#### 1. Абстракція
```typescript
abstract class Shape {
  protected renderer: Renderer;

  constructor(renderer: Renderer) {
    this.renderer = renderer;
  }

  abstract draw(): void;
}
```

**Особливості:**
- **Абстрактний клас**: Визначає інтерфейс
- **Композиція**: Містить посилання на імплементацію
- **Делегування**: Використовує імплементацію для виконання

#### 2. Конкретні абстракції
```typescript
class Circle extends Shape {
  draw(): void {
    this.renderer.renderCircle();
  }
}

class Square extends Shape {
  draw(): void {
    this.renderer.renderSquare();
  }
}
```

**Особливості:**
- **Наслідування**: Розширює абстракцію
- **Делегування**: Викликає методи імплементації
- **Спеціалізація**: Кожна має свою логіку

#### 3. Імплементація
```typescript
interface Renderer {
  renderCircle(): void;
  renderSquare(): void;
}
```

**Особливості:**
- **Інтерфейс**: Визначає контракт імплементації
- **Незалежність**: Може змінюватися окремо від абстракції
- **Гнучкість**: Легко додавати нові імплементації

#### 4. Конкретні імплементації
```typescript
class VectorRenderer implements Renderer {
  renderCircle(): void {
    console.log('Drawing circle as vector');
  }
}

class RasterRenderer implements Renderer {
  renderCircle(): void {
    console.log('Drawing circle as pixels');
  }
}
```

**Особливості:**
- **Реалізація**: Конкретна логіка рендерингу
- **Варіанти**: Різні способи імплементації
- **Замінність**: Можна змінювати під час виконання

## Приклади використання

### 1. Графічні примітиви
- **Абстракція**: Shape, Circle, Square
- **Імплементація**: VectorRenderer, RasterRenderer
- **Перевага**: Незалежні зміни форми та способу рендерингу

### 2. База даних
- **Абстракція**: UserRepository, ProductRepository
- **Імплементація**: MySQLDatabase, PostgreSQLDatabase
- **Перевага**: Незалежні зміни репозиторіїв та БД

### 3. UI компоненти
- **Абстракція**: Button, Input, Select
- **Імплементація**: WindowsTheme, MacTheme
- **Перевага**: Незалежні зміни компонентів та тем

## Порівняння з іншими патернами

### Bridge vs Adapter
- **Bridge**: Розділяє абстракцію від імплементації
- **Adapter**: Адаптує несумісні інтерфейси

### Bridge vs Strategy
- **Bridge**: Розділяє абстракцію та імплементацію
- **Strategy**: Змінює алгоритм виконання

### Bridge vs Decorator
- **Bridge**: Розділяє на дві ієрархії
- **Decorator**: Додає функціональність до об'єкта

## Альтернативи

1. **Inheritance** - для простих випадків
2. **Composition** - для простих залежностей
3. **Strategy Pattern** - для зміни алгоритмів
4. **Factory Pattern** - для створення об'єктів

## Висновок

Bridge - це потужний патерн для розділення абстракції та імплементації. Він особливо корисний коли потрібна гнучкість у комбінуванні різних абстракцій та імплементацій, але може ускладнити архітектуру для простих випадків.
