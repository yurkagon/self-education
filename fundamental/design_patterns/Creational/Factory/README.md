# Патерн Factory (Фабрика)

Клас створює об'єкти залежно від параметрів.

## Опис

Factory - це креаційний патерн проектування, який надає інтерфейс для створення об'єктів у суперкласі, але дозволяє підкласам змінювати тип створюваних об'єктів.

## Основні принципи

- **Інкапсуляція створення**: Логіка створення об'єктів прихована від клієнта
- **Поліморфізм**: Можливість створювати різні типи об'єктів через єдиний інтерфейс
- **Розширюваність**: Легко додавати нові типи об'єктів
- **Розділення відповідальностей**: Відділення логіки створення від бізнес-логіки

## Переваги

- ✅ Приховує складність створення об'єктів
- ✅ Дозволяє легко додавати нові типи
- ✅ Централізує логіку створення
- ✅ Підтримує принцип відкритості/закритості
- ✅ Полегшує тестування

## Недоліки

- ❌ Може ускладнити код при багатьох типах
- ❌ Додає додатковий рівень абстракції
- ❌ Може призвести до великої кількості класів

## Коли використовувати

- Коли не знаєте заздалегідь точний тип об'єкта
- Коли створення об'єкта складна операція
- Коли потрібно створювати об'єкти на основі параметрів
- Коли хочете розширити систему новими типами

## Типи Factory патернів

### 1. Simple Factory (Проста фабрика)
- Один клас-фабрика для всіх типів
- Статичний метод створення

### 2. Factory Method (Метод фабрики)
- Абстрактний клас з абстрактним методом створення
- Кожен підклас реалізує свій метод створення

### 3. Abstract Factory (Абстрактна фабрика)
- Фабрика фабрик
- Створює сімейства пов'язаних об'єктів

## Реалізація (typescript.ts)

### Структура коду

```typescript
// Абстрактний базовий клас
abstract class Animal {
  protected name: string;

  constructor(name: string) {
    this.name = name;
  }

  public abstract sayName(): void;
}

// Конкретні реалізації
class Dog extends Animal {
  public sayName(): void {
    console.log(`The dog name is ${this.name}`);
  }
}

class Cat extends Animal {
  public sayName(): void {
    console.log(`The cat name is ${this.name}`);
  }
}

// Інтерфейс конфігурації
interface IAnimalConfig {
  type: string;
  name: string;
}

// Фабрика
class AnimalFactory {
  public static readonly animalTypes = {
    cat: Cat,
    dog: Dog
  };

  public static createAnimal(config: IAnimalConfig): Animal {
    const { type, name } = config;
    const AnimalClass = AnimalFactory.animalTypes[type];
    return new AnimalClass(name);
  }
}
```

### Використання

```typescript
const dog = AnimalFactory.createAnimal({ type: 'dog', name: 'Hachiko' });
const cat = AnimalFactory.createAnimal({ type: 'cat', name: 'Some cat' });

dog.sayName(); // The dog name is Hachiko
cat.sayName(); // The cat name is Some cat
```

## Особливості реалізації

### 1. Абстрактний базовий клас
- Визначає спільний інтерфейс
- Містить загальну логіку
- Абстрактні методи для перевизначення

### 2. Конкретні класи
- Наслідують базовий клас
- Реалізують специфічну логіку
- Можуть мати власні властивості

### 3. Фабрика
- Статичний словник типів
- Метод створення на основі конфігурації
- Централізована логіка створення

### 4. Інтерфейс конфігурації
- Типізовані параметри
- Валідація вхідних даних
- Гнучкість налаштування

## Розширення функціональності

### Додавання нового типу

```typescript
class Bird extends Animal {
  public sayName(): void {
    console.log(`The bird name is ${this.name}`);
  }
}

// Оновлення фабрики
class AnimalFactory {
  public static readonly animalTypes = {
    cat: Cat,
    dog: Dog,
    bird: Bird  // Новий тип
  };
}
```

## Приклади використання

- **UI компоненти**: Створення різних типів кнопок, форм
- **База даних**: Створення різних типів з'єднань
- **Файлова система**: Створення різних типів файлів
- **Ігри**: Створення різних типів персонажів, зброї
- **Логування**: Створення різних типів логерів

## Альтернативи

1. **Builder Pattern** - для складних об'єктів з багатьма параметрами
2. **Prototype Pattern** - для клонування існуючих об'єктів
3. **Dependency Injection** - для ін'єкції залежностей

## Висновок

Factory патерн - це потужний інструмент для створення об'єктів, який забезпечує гнучкість, розширюваність та підтримуваність коду. Він особливо корисний у великих системах, де потрібно створювати різні типи об'єктів на основі динамічних параметрів.
