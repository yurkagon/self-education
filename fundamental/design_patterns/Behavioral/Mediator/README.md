# Патерн Mediator (Посередник)

Клієнт через чат передає повідомлення всім іншим клієнтам, які підписані

## Опис

Mediator - це патерн поведінки, який визначає об'єкт, що інкапсулює спосіб взаємодії між об'єктами. Патерн дозволяє зменшити зв'язність між об'єктами, змушуючи їх обмінюватися повідомленнями через посередника, а не безпосередньо один з одним.

## Основні принципи

- **Централізація**: Всі взаємодії через одного посередника
- **Зменшення зв'язності**: Об'єкти не знають один про одного
- **Спрощення**: Спрощує взаємодію між об'єктами
- **Гнучкість**: Легко змінювати логіку взаємодії
- **Розширюваність**: Легко додавати нові об'єкти

## Переваги

- ✅ Зменшує зв'язність між об'єктами
- ✅ Централізує логіку взаємодії
- ✅ Спрощує взаємодію між об'єктами
- ✅ Легко додавати нові об'єкти
- ✅ Підтримує принцип єдиної відповідальності
- ✅ Покращує тестованість

## Недоліки

- ❌ Може стати "божественним об'єктом"
- ❌ Складність у налагодженні
- ❌ Може ускладнити архітектуру
- ❌ Потенційні проблеми з продуктивністю
- ❌ Складність у розумінні

## Коли використовувати

- Коли об'єкти мають багато взаємних залежностей
- Коли хочете зменшити зв'язність між об'єктами
- Коли потрібна централізація логіки взаємодії
- Коли хочете спростити взаємодію між об'єктами
- Коли потрібна гнучкість у зміні логіки

## Структура патерну

### Компоненти

1. **Mediator** - інтерфейс посередника
2. **ConcreteMediator** - конкретний посередник
3. **Colleague** - інтерфейс колек
4. **ConcreteColleague** - конкретний колега
5. **Client** - клієнт

## Реалізація (base.ts)

### Аналіз коду

#### 1. Mediator (Chat)
```typescript
class Chat {
  private subscribers: Array<Client> = [];

  public send(author: Client, message: string): void {
    for(let index in this.subscribers) {
      const subscriber = this.subscribers[index];
      if (subscriber !== author) {
        subscriber.send(message);
      }
    }
  }

  public register(user: Client): void {
    this.subscribers.push(user);
  }
}
```

**Особливості:**
- **Централізація**: Всі повідомлення проходять через чат
- **Реєстрація**: Реєструє користувачів у системі
- **Розсилка**: Відправляє повідомлення всім, крім автора
- **Координація**: Координує взаємодію між користувачами

#### 2. Colleague (Client)
```typescript
class Client {
  private name: string;
  private mediator: Chat;

  constructor(mediator: Chat, name: string) {
    this.name = name;
    this.mediator = mediator;
    this.mediator.register(this);
  }

  send(message: string) {
    this.mediator.send(this, message);
  }

  recieve(message: string) {
    console.log(message);
  }
}
```

**Особливості:**
- **Залежність**: Залежить від посередника
- **Незалежність**: Не знає про інших клієнтів
- **Делегування**: Делегує відправку повідомлень посереднику
- **Отримання**: Отримує повідомлення через метод recieve

#### 3. Використання
```typescript
const chat = new Chat();

const user1 = new Client(chat, 'yurkagon');
const user2 = new Client(chat, 'minecrafter2008');
```

**Особливості:**
- **Створення**: Спочатку створюється посередник
- **Реєстрація**: Клієнти автоматично реєструються при створенні
- **Взаємодія**: Взаємодіють через посередника, а не безпосередньо

## Типи Mediator патернів

### 1. Simple Mediator (Простий посередник)
- Одна централізована взаємодія
- Мінімальна логіка
- Найпростіший варіант

### 2. Complex Mediator (Складний посередник)
- Багато типів взаємодій
- Складна логіка координації
- Більше функціональності

### 3. Event-based Mediator (Подійний посередник)
- Використовує події
- Підписування на події
- Більш гнучкий підхід

## Приклади використання

### 1. Чат система
```typescript
// Посередник координує повідомлення між користувачами
const chat = new Chat();
const user1 = new Client(chat, 'user1');
const user2 = new Client(chat, 'user2');

user1.send('Hello!'); // Відправляється через чат
```

### 2. UI компоненти
```typescript
// Посередник координує взаємодію між компонентами
class DialogMediator {
  notify(sender: Component, event: string): void {
    // Координує взаємодію між компонентами
  }
}
```

### 3. Торгова біржа
```typescript
// Посередник координує угоди між учасниками
class ExchangeMediator {
  matchBuyerAndSeller(buyer: Trader, seller: Trader): void {
    // Координує угоди
  }
}
```

## Розширення функціональності

### Додавання фільтрації
```typescript
class Chat {
  send(author: Client, message: string): void {
    const filteredMessage = this.filter(message);
    // Відправка відфільтрованого повідомлення
  }

  private filter(message: string): string {
    // Логіка фільтрації
    return message;
  }
}
```

### Додавання логування
```typescript
class Chat {
  send(author: Client, message: string): void {
    console.log(`[${author.name}]: ${message}`);
    // Відправка повідомлення
  }
}
```

### Додавання маршрутизації
```typescript
class Chat {
  send(author: Client, message: string, target?: Client): void {
    if (target) {
      target.receive(message);
    } else {
      // Відправка всім
    }
  }
}
```

## Порівняння з іншими патернами

### Mediator vs Observer
- **Mediator**: Двостороння взаємодія через посередника
- **Observer**: Одностороння взаємодія (один до багатьох)

### Mediator vs Facade
- **Mediator**: Координує взаємодію між об'єктами
- **Facade**: Спрощує інтерфейс до підсистеми

### Mediator vs Command
- **Mediator**: Координує взаємодію
- **Command**: Інкапсулює запит як об'єкт

## Альтернативи

1. **Observer Pattern** - для односторонньої взаємодії
2. **Event Bus** - для подійної архітектури
3. **Message Queue** - для асинхронної взаємодії
4. **Direct Communication** - для простих випадків

## Висновок

Mediator - це потужний патерн для зменшення зв'язності між об'єктами. Він особливо корисний для складних систем з багатьма взаємними залежностями, але може ускладнити архітектуру та призвести до створення "божественного об'єкта", якщо не використовувати обережно.
